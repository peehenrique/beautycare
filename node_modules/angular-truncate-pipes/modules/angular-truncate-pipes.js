import { NgModule, Pipe } from '@angular/core';

class WordsPipe {
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args = 4) {
        let /** @type {?} */ res = value;
        if (value && args > 0) {
            const /** @type {?} */ valueWords = value.split(/\s+/);
            if (valueWords.length > args) {
                res = valueWords.slice(0, args).join(' ') + '…';
            }
        }
        return res;
    }
}
WordsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'words'
            },] },
];
/**
 * @nocollapse
 */
WordsPipe.ctorParameters = () => [];

class SplitcharactersPipe {
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args = 10) {
        let /** @type {?} */ res = value;
        if (value && value.length > args && args > 0) {
            const /** @type {?} */ prefix = value.substring(0, args / 2);
            const /** @type {?} */ postfix = value.substring(value.length - args / 2, value.length);
            res = `${prefix}...${postfix}`;
        }
        return res;
    }
}
SplitcharactersPipe.decorators = [
    { type: Pipe, args: [{
                name: 'splitcharacters'
            },] },
];
/**
 * @nocollapse
 */
SplitcharactersPipe.ctorParameters = () => [];

class CharactersPipe {
    /**
     * @param {?} value
     * @param {?=} args
     * @param {?=} breakOnWord
     * @return {?}
     */
    transform(value, args = 10, breakOnWord) {
        let /** @type {?} */ res = value;
        if (value && value.length > args && args > 0) {
            value = value.substring(0, args);
            if (breakOnWord) {
                while (value.charAt(value.length - 1) === ' ') {
                    value = value.substr(0, value.length - 1);
                }
            }
            else {
                const /** @type {?} */ lastspace = value.lastIndexOf(' ');
                // get last space
                if (lastspace !== -1) {
                    value = value.substr(0, lastspace);
                }
            }
            res = `${value}...`;
        }
        return res;
    }
}
CharactersPipe.decorators = [
    { type: Pipe, args: [{
                name: 'characters'
            },] },
];
/**
 * @nocollapse
 */
CharactersPipe.ctorParameters = () => [];

class TruncatePipesModule {
    /**
     * Use in AppModule
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: TruncatePipesModule,
            providers: []
        };
    }
    /**
     * Use in features modules with lazy loading
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: TruncatePipesModule,
            providers: []
        };
    }
}
TruncatePipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CharactersPipe,
                    SplitcharactersPipe,
                    WordsPipe
                    // Pipes.
                    // Directives.
                ],
                exports: [
                    CharactersPipe,
                    SplitcharactersPipe,
                    WordsPipe
                    // Pipes.
                    // Directives.
                ]
            },] },
];
/**
 * @nocollapse
 */
TruncatePipesModule.ctorParameters = () => [];

// Public classes.

/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-truncate-pipes
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { TruncatePipesModule, CharactersPipe as ɵa, SplitcharactersPipe as ɵb, WordsPipe as ɵc };
//# sourceMappingURL=angular-truncate-pipes.js.map
